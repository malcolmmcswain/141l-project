lim 0
swp $0 $08          // store count = 0 in r8
lim 13
lwd $0 $09          // load squared_l into r9 
lim 14
lwd $0 $10          // load squared_r into r10
lim 0 
swp $0 $11          // store odd_l = 0 in r11
lim 1 
swp $0 $12          // store odd_r = 1 in r12
lim 0
swp $0 $13          // store curr_l = 0 in r13
lim 0
swp $0 $14          // store curr_r = 0 in r1


swp $1 $13          // load curr_l into $1    START OF LOOP
swp $2 $09          // load squared_l into $2
slt $3 $2 $1        // $3 = squared_l < curr_l
swp $1 $13          // store curr_l into $13
swp $2 $09          // store squared_l into $9
lim 1
swp $0 $01
lim 58
beq $0 $3 $1        // EXIT LOOP if squared_l < curr_l
swp $1 $13          // load curr_l into $1
swp $2 $09          // load squared_l into $2
slt $3 $1 $2        // $3 = squared_l > curr_l
swp $1 $13          // store curr_l into $13
swp $2 $09          // store squared_l into $9
lim 10            
beq $0 $1 $3        // jump to start of loop body
swp $1 $14          // load curr_r into $1
swp $2 $10          // load squared_r into $2
slt $3 $2 $1        // $3 = squared_r < curr_r
swp $1 $14          // store curr_r into $14
swp $2 $10          // store squared_r into $10
lim 1
swp $0 $01
lim 42
beq $0 $1 $3        // EXIT LOOP
swp $1 $14          // load curr_r into $1   START OF LOOP BODY
swp $2 $12          // load odd_r into $2
add $3 $1 $2        // $3 = curr_r + odd_r
swp $2 $12          // store odd_r into $12
slt $2 $3 $1        // $2 = 1 if overflow and 0 if no over flow
lim 0
add $1 $3 $0        // curr_r = curr_r + odd_r
swp $1 $14          // store curr_r into $14
swp $0 $01          // $1 = 0
lim 5
beq $0 $2 $1        // branch if no over flow
swp $1 $13          // load curr_1 into $1
lim 1
add $1 $1 $0        // curr_l = curr_l + 1 (for overflow)
swp $1 $13          // store curr_l into $13
swp $1 $13          // load curr_l into $1
swp $2 $11          // load odd_l into $2
add $1 $1 $2        // curr_1 = curr_1 + odd_1 
swp $1 $13          // store curr_l into $13
swp $2 $11          // store odd_l into $11
swp $2 $12          // load odd_r into $2
lim 2
add $3 $2 $0        // $3 = curr_r + 2
slt $1 $3 $2        // $1 = 1 if overflow and 0 if no over flow
add $2 $2 $0        // odd_r += 2
swp $2 $12          // store odd_r into $12
lim 0
swp $0 $02
lim 5
beq $0 $2 $1        // branch if no over flow
swp $1 $11          // load odd_l into $1
lim 1
add $1 $1 $0        // odd_l = odd_l + 1 (for overflow)
swp $1 $11          // store odd_l into $11
swp $1 $08           // load count into $1
lim 1
add $1 $1 $0        // count += 1
swp $1 $08           // store count into $8
lim 15
lwd $0 $01
beq $1 $1 $1        // jump to top of loop
swp $1 $08           // load count into $1  END OF LOOP JUMPS HERE
lim 1
sub $1 $1 $0        // count -= 1
lim 18
swd $0 $01