lim 3
lwd $0 $10       // load divisor_l to r10 LOAD IMMEDIATES
lim 4
lwd $0 $11       // load divisor_r to r11

lim 1
swp $0 $12       // load 1 as divisor to r12
swp $1 $10       // DIVIDENT << 1 STARTS
add $1 $1 $1     // divident_l = divident_l + divident_l
swp $1 $10       // (sto$e divident_l to $10)
swp $2 $11       // (load divident_$ to $2)
add $3 $2 $2     // new_divident_$  = divident_$ + divident_$
slt $1 $3 $2    
swp $3 $11       // divident_$ = new_divident_$ (sto$e new_divident_$ to $11)
lim 0
swp $2 $00       // $2 = 0
lim 5          
beq $0 $1 $2     // if (new_divident_$ < divident_$) {
swp $1 $10       // (load divident_l to $1)
lim 1
add $1 $1 $0     // divident_l += 1 }
swp $1 $10       // DIVIDENT << 1 ENDS
lim 0      
swp $0 $09       // i = 0 FOR LOOP START: FOR LOOP INTRO STATEMENT STARTS
lim 15          
swp $1 $09       // (JUMP BACK to PREVIOUS line at the end of fo$-loop)
slt $2 $1 $0     // if (i >= 15){
swp $1 $09       // (sto$e i to $9)
lim 0
swp $0 $01
lim 9
lwd $0 $03
beq $3 $1 $2     // skip fo$ loop body} FOR LOOP INTRO STATEMENT ENDS
swp $1 $10       // IF STATEMENT STARTS
lim 1      
slt $2 $1 $0     // if (divident_l >= 1){
swp $1 $10       // (sto$e divident_l to $10)
lim 0
swp $0 $03
lim 10
beq $0 $2 $3     // go inside if statement body}
swp $2 $11       // (load divident_$ to $2)
swp $3 $12       // (load diviso$ to $3)
slt $1 $2 $3     // else if (divident_$ < diviso$){
swp $2 $11       // (sto$e divident_$ to $11)
swp $3 $12       // (sto$e diviso$ to $12)
lim 1
swp $0 $02
lim 21  
beq $0 $1 $2    // skip the if statement body} IF STATMENT ENDS
swp $2 $11      // DIVIDENT -= DIVISOR STARTS divident -= diviso$ IF STATE BODY STARTS
swp $3 $12      // (load diviso$ to $3)
slt $1 $2 $3
swp $2 $11      // (sto$e divident_$ to $11)
lim 0 
swp $0 $02
lim 5          
beq $0 $1 $2    // if (divident_$ < diviso$) {
swp $1 $10      // (load divident_l to $1)
lim 1
sub $1 $1 $0    // divident_l -= 1}
swp $1 $10      // (sto$e divident_l to $10)
swp $2 $11      // (load divident_$ to $2)
sub $2 $2 $3    // divident_$ -= diviso$
swp $2 $11      // (sto$e divident_$ to $11)
swp $3 $12      // DIVIDENT -= DIVISOR ENDS
swp $2 $07      // QUOTIENT_FRAC += 1 BEGINS: load QUOTIENT_FRAC_R to $2
lim 1
add $3 $2 $0        // $3 = QUOTIENT_FRAC_R + 1
slt $1 $2 $3        // $1 = QUOTIENT_FRAC_R < QUOTIENT_FRAC_R +1
swp $3 $06           // Store $3 (temp) into $6
lim 5
swp $0 $03         // Store 5(jump amount) in $3
lim 1   
beq $3 $0 $1     // if (QUOTIENT_FRAC_R < QUOTIENT_FRAC_R + 1) skip if statement body
swp $3 $08       // BEGIN IF STATEMENT: load QUOTIENT_FRAC_L into $3
lim 1
add $3 $3 $0    // QUOTIENT_FRAC_L += 1
swp $3 $08       // store QUOTIENT_FRAC_L into $8
swp $3 $06      // ENF IF STATEMENT: BEQ jumps here $3 = temp
lim 0
add $2 $3 $0    // quotient_fraction_r = TEMP
swp $2 $07      // QUOTIENT_FRAC += 1 ENDS: store QUOTIENT_FRAC_R to $7
swp $1 $08      // QUOTIENT_FRAC << 1 STARTS: load quotient_fraction_l into $1
add $1 $1 $1    // quotient_f$action_l = quotient_f$action_l + quotient_f$action_l
swp $1 $08      // store quotient_fraction_l into $08
swp $2 $07     // load quotient_fraction_r to $2
add $3 $2 $2   // new_quotient_fraction_r = quotient_r << 1
slt $1 $3 $2
swp $3 $07     // store new_quotient_fraction_r to $7
lim 0
swp $2 $00  // $2 = 0
lim 5
beq $0 $1 $2 // if (new_quotient_fraction_r < quotient_fraction_r) 
swp $1 $08 // load quotient_fraction_l into $1
lim 1
add $1 $1 $0  // quotient_fraction_l += 1
swp $1 $08      // QUOTIENT_FRACTION << 1 ENDS: store quotient_fraction_l into $8
swp $1 $10      // DIVIDENT << 1 STARTS
add $1 $1 $1    // divident_l = divident_l + divident_l
swp $1 $10      // (sto$e divident_l to $10)
swp $2 $11      // (load divident_$ to $2)
add $3 $2 $2    // new_divident_$  = divident_$ + divident_$
slt $1 $3 $2    
swp $3 $11      // divident_$ = new_divident_$ (sto$e new_divident_$ to $11)
lim 0
swp $2 $00       // $2 = 0
lim 5          
beq $0 $1 $2    // if (new_divident_$ < divident_$) {
swp $1 $10      // (load divident_l to $1)
lim 1
add $1 $1 $0    // divident_l += 1 }
swp $1 $10      // DIVIDENT << 1 ENDS
swp $1 $09       // (load i to $1) FOR LOOP OUTTRO STATEMENT STARTS
lim 1
add $1 $1 $0    // i++
swp $1 $09       // (sto$e i to $9)
lim 10
lwd $0 $01
beq $1 $0 $0    // always b$anch back to the top of fo$ loop FOR LOOP OUTTRO STATEMENT ENDS : FOR LOOP ENDS
lim 5
swd $0 $08
lim 6
swd $0 $07