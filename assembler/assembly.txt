lim 0
lwd $0 $10      // load divident_l to r10 LOAD IMMEDIATES
lim 1
lwd $0 $11      // load divident_r to r11
lim 2
lwd $0 $12      // load divisor to r12
swp $1 $10      // WHILE LOOP STARTS
lim 1       
slt $2 $1 $0    // if (divident_l >= 1){
swp $1 $10      // (sto$e divident_l to $10)
lim 0
swp $0 $03      
lim 11
beq $0 $2 $3    // go inside while loop body}
swp $2 $11      // (load divident_$ to $2)
swp $3 $12      // (load diviso$ to $3)
slt $1 $2 $3    // else if (divident_$ < diviso$){
swp $2 $11      // (sto$e divident_$ to $11)
swp $3 $12      // (sto$e diviso$ to $12) 
lim 1
swp $0 $02
lim 7   
lwd $0 $03
beq $3 $1 $2    // skip the while loop body}
swp $2 $11      // WHILE LOOP BODY STARTS: DIVIDENT -= DIVISOR STARTS
swp $3 $12      // (load diviso$ to $3)
slt $1 $2 $3
swp $2 $11      // (sto$e divident_$ to $11)
lim 0  
swp $0 $02
lim 5           
beq $0 $1 $2    // if (divident_$ < diviso$) {
swp $1 $10      // (load divident_l to $1)
lim 1
sub $1 $1 $0    // divident_l -= 1}
swp $1 $10      // (sto$e divident_l to $10)
swp $2 $11      // (load divident_$ to $2)
sub $2 $2 $3    // divident_$ -= diviso$
swp $2 $11      // (sto$e divident_$ to $11)
swp $3 $12      // DIVIDENT -= DIVISOR ENDS
swp $2 $14      // QUOTIENT_INT ++ STARTS
lim 1           
add $3 $2 $0    // new_quotient_intege$_$  = quotient_intege$_$ + 1
slt $1 $3 $2     
swp $3 $14      // quotient_intege$_$ = new_quotient_intege$_$ (sto$e new_quotient_intege$_$ to $14)
lim 0
swp $2 $00       // $2 = 0
lim 5           
beq $0 $1 $2    // if (new_quotient_intege$_$ < quotient_intege$_$) {
swp $1 $13      // (load quotient_intege$_l to $1) 
lim 1           
add $1 $1 $0    // quotient_intege$_l += 1 
swp $1 $13      // QUOTIENT_INT ++ ENDS: WHILE LOOP BODY ENDS
lim 8
lwd $0 $01      // COUNT HOW MANY LINES NEEDED TO BRANCH BACK
beq $1 $0 $0    // WHILE LOOP ENDS

swp $1 $10      // DIVIDENT << 1 STARTS
add $1 $1 $1    // divident_l = divident_l + divident_l
swp $1 $10      // (sto$e divident_l to $10) 
swp $2 $11      // (load divident_$ to $2)
add $3 $2 $2    // new_divident_$  = divident_$ + divident_$
slt $1 $3 $2     
swp $3 $11      // divident_$ = new_divident_$ (sto$e new_divident_$ to $11)
lim 0 
swp $2 $00       // $2 = 0
lim 5           
beq $0 $1 $2    // if (new_divident_$ < divident_$) {
swp $1 $10      // (load divident_l to $1)
lim 1
add $1 $1 $0    // divident_l += 1 }
swp $1 $10      // DIVIDENT << 1 ENDS

lim 0       
swp $0 $09       // i = 0 FOR LOOP START: FOR LOOP INTRO STATEMENT STARTS
lim 7           
swp $1 $09       // (JUMP BACK to PREVIOUS line at the end of fo$-loop)
slt $2 $1 $0    // if (i >= 7){
swp $1 $09       // (sto$e i to $9)
lim 0
swp $0 $01
lim 9
lwd $0 $03
beq $3 $1 $2    // skip fo$ loop body} FOR LOOP INTRO STATEMENT ENDS
swp $1 $10      // IF STATEMENT STARTS
lim 1       
slt $2 $1 $0    // if (divident_l >= 1){
swp $1 $10      // (sto$e divident_l to $10)
lim 0
swp $0 $03
lim 10
beq $0 $2 $3    // go inside if statement body}
swp $2 $11      // (load divident_$ to $2)
swp $3 $12      // (load diviso$ to $3)
slt $1 $2 $3    // else if (divident_$ < diviso$){
swp $2 $11      // (sto$e divident_$ to $11)
swp $3 $12      // (sto$e diviso$ to $12) 
lim 1
swp $0 $02
lim 21   
beq $0 $1 $2    // skip the if statement body} IF STATMENT ENDS
swp $2 $11      // DIVIDENT -= DIVISOR STARTS divident -= diviso$ IF STATE BODY STARTS
swp $3 $12      // (load diviso$ to $3)
slt $1 $2 $3
swp $2 $11      // (sto$e divident_$ to $11)
lim 0  
swp $0 $02
lim 5           
beq $0 $1 $2    // if (divident_$ < diviso$) {
swp $1 $10      // (load divident_l to $1)
lim 1
sub $1 $1 $0    // divident_l -= 1}
swp $1 $10      // (sto$e divident_l to $10)
swp $2 $11      // (load divident_$ to $2)
sub $2 $2 $3    // divident_$ -= diviso$
swp $2 $11      // (sto$e divident_$ to $11)
swp $3 $12      // DIVIDENT -= DIVISOR ENDS
swp $1 $08      // QUOTIENT_FRAC += 1 STARTS
lim 1
add $1 $1 $0    // quotient_f$action = quotient_f$action + 1
swp $1 $08      // QUOTIENT_FRAC += 1 ENDS: IF STATE BODY ENDS
swp $1 $08      // QUOTIENT_FRAC << 1 STARTS
add $1 $1 $1    // quotient_f$action = quotient_f$action + quotient_f$action
swp $1 $08      // QUOTIENT_FRAC << 1 ENDS
swp $1 $10      // DIVIDENT << 1 STARTS
add $1 $1 $1    // divident_l = divident_l + divident_l
swp $1 $10      // (sto$e divident_l to $10) 
swp $2 $11      // (load divident_$ to $2)
add $3 $2 $2    // new_divident_$  = divident_$ + divident_$
slt $1 $3 $2     
swp $3 $11      // divident_$ = new_divident_$ (sto$e new_divident_$ to $11)
lim 0 
swp $2 $00       // $2 = 0
lim 5           
beq $0 $1 $2    // if (new_divident_$ < divident_$) {
swp $1 $10      // (load divident_l to $1)
lim 1
add $1 $1 $0    // divident_l += 1 }
swp $1 $10      // DIVIDENT << 1 ENDS
swp $1 $09       // (load i to $1) FOR LOOP OUTTRO STATEMENT STARTS
lim 1
add $1 $1 $0    // i++
swp $1 $09       // (sto$e i to $9)
lim 10
lwd $0 $01
beq $1 $0 $0    // always b$anch back to the top of fo$ loop FOR LOOP OUTTRO STATEMENT ENDS : FOR LOOP ENDS

lim 4
swd $0 $13
lim 5
swd $0 $14
lim 6
swd $0 $08

lim 4
lwd $0 $01
lim 5
lwd $0 $02
lim 6
lwd $0 $03
